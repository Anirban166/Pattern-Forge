<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Shirt Pattern</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <header>3D Parametric Shirt Pattern</header>
  <canvas id="canvas"></canvas>
  <div class="controls">
    <div class="control-group">
      <label for="patternPreset">Pattern Preset</label>
      <select id="patternPreset">
        <option value="basic">Basic Shirt</option>
        <option value="shirtWithCollar">Shirt with Collar</option>
        <option value="shirtWithSleeves">Shirt with Sleeves</option>
        <option value="shirtWithYoke">Shirt with Yoke</option>
        <option value="shirtFull">Full Shirt</option>
      </select>
    </div>
    <div class="control-group">
      <label for="width">Width</label>
      <input type="range" id="width" min="50" max="200" value="90" step="1">
    </div>
    <div class="control-group">
      <label for="height">Height</label>
      <input type="range" id="height" min="50" max="200" value="100" step="1">
    </div>
    <div class="control-group">
      <label for="scale">Uniform Scale</label>
      <input type="range" id="scale" min="0.5" max="2.0" value="1.0" step="0.01">
    </div>
    <div class="control-group">
      <label for="fillColor">Fill Color</label>
      <input type="color" id="fillColor" value="#1e1e1e">
    </div>
  </div>

  <div class="measurement" id="measurementDisplay">Total Measurement: 0</div>

  <div class="zoom-buttons">
    <button class="zoom-button" id="zoomIn"><i class="fas fa-plus"></i></button>
    <button class="zoom-button" id="zoomOut"><i class="fas fa-minus"></i></button>
  </div>

  <div class="controls-bottom-right">
    <div class="toggle-control" id="mirrorPatternContainer">
      <label for="mirrorPatternCheckbox">Mirror Pattern</label>
      <input type="checkbox" id="mirrorPatternCheckbox">
    </div>
    <div class="toggle-control" id="toggleLabelsContainer">
      <label for="toggleLabelsCheckbox">Show Labels</label>
      <input type="checkbox" id="toggleLabelsCheckbox" checked>
    </div>
    <div class="control-group">
        <button id="downloadDxfButton">Download DXF</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1e1e1e); 

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 200); 

    const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('canvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const group = new THREE.Group(); 
    scene.add(group);
    
    const labelGroup = new THREE.Group(); 
    scene.add(labelGroup);

    const fontLoader = new FontLoader();
    let font;

    fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.153.0/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
      font = loadedFont;
      updatePattern(); 
    });

    const patternPresets = {
      basic: [
        { type: "line", points: [[90, 0], [90, 40]], label: "Line: (90,0) to (90,40)" },
        { type: "bezier", points: [[90, 40], [90, 60], [63, 80], [45, 100]], label: "Bezier: (90,40), (90,60), (63,80), (45,100)" },
        { type: "line", points: [[45, 100], [0, 100]], label: "Line: (45,100) to (0,100)" },
        { type: "line", points: [[0, 100], [0, 0]], label: "Line: (0,100) to (0,0)" },
        { type: "bezier", points: [[0, 0], [18, -40], [72, -40], [90, 0]], label: "Bezier: (0,0), (18,-40), (72,-40), (90,0)" }
      ],
      shirtWithCollar: [
        { type: "line", points: [[90, 0], [90, 40]], label: "Line: (90,0) to (90,40)" },
        { type: "bezier", points: [[90, 40], [90, 60], [63, 80], [45, 100]], label: "Bezier: (90,40), (90,60), (63,80), (45,100)" },
        { type: "line", points: [[45, 100], [0, 100]], label: "Line: (45,100) to (0,100)" },
        { type: "line", points: [[0, 100], [0, 40]], label: "Line: (0,100) to (0,40)" },
        { type: "bezier", points: [[0, 40], [18, -10], [72, -10], [90, 0]], label: "Bezier: (0,40), (18,-10), (72,-10), (90,0)" }
      ],
      shirtWithSleeves: [
        { type: "line", points: [[90, 0], [90, 40]], label: "Line: (90,0) to (90,40)" },
        { type: "bezier", points: [[90, 40], [90, 60], [63, 80], [45, 100]], label: "Bezier: (90,40), (90,60), (63,80), (45,100)" },
        { type: "line", points: [[45, 100], [0, 100]], label: "Line: (45,100) to (0,100)" },
        { type: "line", points: [[0, 100], [0, 0]], label: "Line: (0,100) to (0,0)" },
        { type: "bezier", points: [[0, 0], [18, -40], [72, -40], [90, 0]], label: "Bezier: (0,0), (18,-40), (72,-40), (90,0)" },
        { type: "break" },
        { type: "bezier", points: [[90, 40], [110, 30], [130, 60], [150, 50]], label: "Bezier: (90,40), (110,30), (130,60), (150,50)" },
        { type: "line", points: [[150, 50], [160, 70]], label: "Line: (150,50) to (160,70)" },
        { type: "line", points: [[160, 70], [170, 90]], label: "Line: (160,70) to (170,90)" },
        { type: "line", points: [[170, 90], [160, 110]], label: "Line: (170,90) to (160,110)" },
        { type: "line", points: [[160, 110], [140, 120]], label: "Line: (160,110) to (140,120)" },
        { type: "line", points: [[140, 120], [130, 100]], label: "Line: (140,120) to (130,100)" },
        { type: "line", points: [[130, 100], [150, 100]], label: "Line: (130,100) to (150,100)" }
      ],
      shirtWithYoke: [
        { type: "line", points: [[90, 0], [90, 40]], label: "Line: (90,0) to (90,40)" },
        { type: "bezier", points: [[90, 40], [90, 60], [63, 80], [45, 100]], label: "Bezier: (90,40), (90,60), (63,80), (45,100)" },
        { type: "line", points: [[45, 100], [0, 100]], label: "Line: (45,100) to (0,100)" },
        { type: "line", points: [[0, 100], [0, 40]], label: "Line: (0,100) to (0,40)" },
        { type: "line", points: [[0, 40], [45, 40]], label: "Line: (0,40) to (45,40)" },
        { type: "line", points: [[45, 40], [90, 40]], label: "Line: (45,40) to (90,40)" }
      ],
      shirtFull: [
        { type: "line", points: [[20, 0], [80, 0]], label: "Line: (20,0) to (80,0)" },
        { type: "bezier", points: [[80, 0], [85, 5], [83, 10], [80, 12]], label: "Bezier: (80,0), (85,5), (83,10), (80,12)" },
        { type: "line", points: [[80, 12], [80, 30]], label: "Line: (80,12) to (80,30)" },
        { type: "bezier", points: [[80, 30], [78, 35], [75, 40], [70, 42]], label: "Bezier: (80,30), (78,35), (75,40), (70,42)" },
        { type: "bezier", points: [[70, 42], [65, 50], [60, 65], [60, 80]], label: "Bezier: (70,42), (65,50), (60,65), (60,80)" },
        { type: "line", points: [[60, 80], [60, 100]], label: "Line: (60,80) to (60,100)" },
        { type: "line", points: [[60, 100], [20, 100]], label: "Line: (60,100) to (20,100)" },
        { type: "line", points: [[20, 100], [20, 80]], label: "Line: (20,100) to (20,80)" },
        { type: "bezier", points: [[20, 80], [25, 65], [30, 50], [35, 42]], label: "Bezier: (20,80), (25,65), (30,50), (35,42)" },
        { type: "bezier", points: [[35, 42], [40, 40], [42, 35], [40, 30]], label: "Bezier: (35,42), (40,40), (42,35), (40,30)" },
        { type: "line", points: [[40, 30], [20, 12]], label: "Line: (40,30) to (20,12)" },
        { type: "line", points: [[20, 12], [20, 0]], label: "Line: (20,12) to (20,0)" },
        { type: "break"}, 
        { type: "line", points: [[120, 0], [180, 0]], label: "Line: (120,0) to (180,0)" },
        { type: "bezier", points: [[120, 0], [125, 5], [123, 15], [130, 18]], label: "Bezier: (120,0), (125,5), (123,15), (130,18)" },
        { type: "line", points: [[130, 18], [130, 32]], label: "Line: (130,18) to (130,32)" },
        { type: "bezier", points: [[130, 32], [132, 37], [135, 42], [140, 44]], label: "Bezier: (130,32), (132,37), (135,42), (140,44)" },
        { type: "bezier", points: [[140, 44], [145, 52], [150, 67], [150, 82]], label: "Bezier: (140,44), (145,52), (150,67), (150,82)" },
        { type: "line", points: [[150, 82], [150, 100]], label: "Line: (150,82) to (150,100)" },
        { type: "line", points: [[150, 100], [120, 100]], label: "Line: (150,100) to (120,100)" },
        { type: "line", points: [[120, 100], [120, 82]], label: "Line: (120,100) to (120,82)" },
        { type: "bezier", points: [[120, 82], [125, 67], [130, 52], [135, 44]], label: "Bezier: (120,82), (125,67), (130,52), (135,44)" },
        { type: "bezier", points: [[135, 44], [138, 42], [140, 37], [138, 32]], label: "Bezier: (135,44), (138,42), (140,37), (138,32)" },
        { type: "line", points: [[138, 32], [120, 18]], label: "Line: (138,32) to (120,18)" },
        { type: "line", points: [[120, 18], [120, 0]], label: "Line: (120,18) to (120,0)" }
      ]
    };

    const generatePatternShape = (patternData, width, height, colorHex, isMirrored = false) => {
      let shape = new THREE.Shape();
      let lastPoint = null;

      const addShapeToGroup = (shp) => {
        if (shp && shp.getPoints().length > 1) {
          const geometry = new THREE.ShapeGeometry(shp);
          const fill = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
            color: new THREE.Color(colorHex),
            side: THREE.DoubleSide
          }));
          group.add(fill);

          const edgeGeo = new THREE.EdgesGeometry(geometry);
          const edgeMat = new THREE.LineBasicMaterial({ color: 0xffffff });
          const edgeLines = new THREE.LineSegments(edgeGeo, edgeMat);
          group.add(edgeLines);
        }
      };

      patternData.forEach((segment) => {
        if (segment.type === "break") {
          addShapeToGroup(shape);
          shape = new THREE.Shape(); 
          lastPoint = null;
          return;
        }

        const processedPoints = segment.points.map(p => isMirrored ? [-p[0], p[1]] : [p[0], p[1]]);
        const scaled = processedPoints.map(p => new THREE.Vector2(p[0] * (width / 100), p[1] * (height / 100)));
        const start = scaled[0];

        if (!lastPoint || !lastPoint.equals(start)) {
          shape.moveTo(start.x, start.y);
        }

        let labelPosition;
        
        if (segment.type === "line") {
          shape.lineTo(scaled[1].x, scaled[1].y);
          lastPoint = scaled[1];
          labelPosition = new THREE.Vector3((scaled[0].x + scaled[1].x) / 2, (scaled[0].y + scaled[1].y) / 2, 5);
        } else if (segment.type === "bezier") {
          shape.bezierCurveTo(scaled[1].x, scaled[1].y, scaled[2].x, scaled[2].y, scaled[3].x, scaled[3].y);
          lastPoint = scaled[3];
          labelPosition = new THREE.Vector3(scaled[0].x, scaled[0].y - 5, 5);
        }
        
        if (font && segment.label && labelGroup.visible && !isMirrored) {
          const labelText = segment.label || ""; 
          
          const textGeometry = new TextGeometry(labelText, {
            font: font,
            size: 4, 
            height: 0.1,
            curveSegments: 4,
            bevelEnabled: false,
          });
          const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const textMesh = new THREE.Mesh(textGeometry, textMaterial);
          textMesh.position.copy(labelPosition);
          textMesh.lookAt(camera.position); 
          labelGroup.add(textMesh); 
        }
      });
      addShapeToGroup(shape); 
    };

    const calculateTotalMeasurement = (patternData, currentWidth, currentHeight) => {
      let total = 0;
      patternData.forEach((segment) => {
        if (segment.type === "break") return;
        const scaledPoints = segment.points.map(p => new THREE.Vector2(p[0] * (currentWidth / 100), p[1] * (currentHeight / 100)));
        for (let i = 0; i < scaledPoints.length - 1; i++) { 
             total += scaledPoints[i].distanceTo(scaledPoints[i+1]);
        }
      });
      return total;
    };

    const patternSelect = document.getElementById('patternPreset');
    const widthSlider = document.getElementById('width');
    const heightSlider = document.getElementById('height');
    const scaleSlider = document.getElementById('scale');
    const colorInput = document.getElementById('fillColor');
    const measurementDisplay = document.getElementById('measurementDisplay');
    
    const toggleLabelsCheckbox = document.getElementById('toggleLabelsCheckbox');
    const mirrorPatternCheckbox = document.getElementById('mirrorPatternCheckbox');
    const downloadDxfButton = document.getElementById('downloadDxfButton');


    toggleLabelsCheckbox.addEventListener('change', () => {
      labelGroup.visible = toggleLabelsCheckbox.checked;
      updatePattern(); 
    });
    
    mirrorPatternCheckbox.addEventListener('change', updatePattern);

    function updatePattern() {
      if (!font) return; 

      while(group.children.length > 0){ group.remove(group.children[0]); }
      while(labelGroup.children.length > 0){ labelGroup.remove(labelGroup.children[0]); }

      const patternName = patternSelect.value;
      const originalPatternData = JSON.parse(JSON.stringify(patternPresets[patternName])); 
      
      let currentWidth = parseFloat(widthSlider.value);
      let currentHeight = parseFloat(heightSlider.value);
      const currentScale = parseFloat(scaleSlider.value);
      const fillColor = colorInput.value;

      const effectiveWidth = currentWidth * currentScale;
      const effectiveHeight = currentHeight * currentScale;
      
      generatePatternShape(originalPatternData, effectiveWidth, effectiveHeight, fillColor, false);

      if (mirrorPatternCheckbox.checked) {
        generatePatternShape(originalPatternData, effectiveWidth, effectiveHeight, fillColor, true);
      }
      
      const totalMeasurement = calculateTotalMeasurement(originalPatternData, effectiveWidth, effectiveHeight);
      measurementDisplay.textContent = `Total Measurement: ${totalMeasurement.toFixed(2)} cm`;
    }

    patternSelect.addEventListener('change', updatePattern);
    widthSlider.addEventListener('input', updatePattern);
    heightSlider.addEventListener('input', updatePattern);
    scaleSlider.addEventListener('input', updatePattern);
    colorInput.addEventListener('input', updatePattern);

    downloadDxfButton.addEventListener('click', async () => {
        const patternName = patternSelect.value;
        const basePatternData = JSON.parse(JSON.stringify(patternPresets[patternName]));
        
        const uiWidth = parseFloat(widthSlider.value);
        const uiHeight = parseFloat(heightSlider.value);
        const uiScale = parseFloat(scaleSlider.value);
        const isMirrored = mirrorPatternCheckbox.checked;

        const effectiveWidth = uiWidth * uiScale;
        const effectiveHeight = uiHeight * uiScale;

        const dxfSegments = [];

        const processSegmentsForDxf = (patternSegs, applyMirror) => {
            patternSegs.forEach(segment => {
                if (segment.type === "break") return;

                const processedDxfPoints = segment.points.map(p => {
                    let x = p[0];
                    let y = p[1];
                    if (applyMirror) {
                        x = -x;
                    }
                    // Apply scaling based on effective dimensions
                    // The points in patternPresets are relative to 100x100 virtual box
                    return [x * (effectiveWidth / 100), y * (effectiveHeight / 100)];
                });
                dxfSegments.push({ type: segment.type, points: processedDxfPoints });
            });
        };

        processSegmentsForDxf(basePatternData, false);
        if (isMirrored) {
            processSegmentsForDxf(basePatternData, true);
        }

        try {
            const response = await fetch('/api/export-dxf', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ segments: dxfSegments }),
            });

            if (response.ok) {
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'pattern.dxf';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } else {
                const errorData = await response.json();
                console.error('DXF Export Error:', errorData.error, errorData.details || '');
                alert(`Error exporting DXF: ${errorData.error}`);
            }
        } catch (error) {
            console.error('Network or other error during DXF export:', error);
            alert('Network error or unexpected issue during DXF export.');
        }
    });

    const zoomInButton = document.getElementById('zoomIn');
    const zoomOutButton = document.getElementById('zoomOut');

    zoomInButton.addEventListener('click', () => {
      camera.position.z = Math.max(camera.position.z - 20, 10); 
      controls.update();
    });

    zoomOutButton.addEventListener('click', () => {
      camera.position.z += 20;
      controls.update();
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const animate = () => {
      requestAnimationFrame(animate);
      controls.update(); 
      renderer.render(scene, camera);
    };
    
    animate();

  </script>
</body>
</html>