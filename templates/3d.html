<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Shirt Pattern</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <header>3D Parametric Shirt Pattern</header>
  <canvas id="canvas"></canvas>
  <div class="controls">
    <div class="control-group">
      <label for="patternPreset">Pattern Preset</label>
      <select id="patternPreset">
        <option value="basic">Basic Shirt</option>
        <option value="shirtWithCollar">Shirt with Collar</option>
        <option value="shirtWithSleeves">Shirt with Sleeves</option>
        <option value="shirtWithYoke">Shirt with Yoke</option>
        <option value="shirtFull">Full Shirt</option>
      </select>
    </div>
    <div class="control-group">
      <label for="width">Width</label>
      <input type="range" id="width" min="50" max="200" value="90" step="1">
    </div>
    <div class="control-group">
      <label for="height">Height</label>
      <input type="range" id="height" min="50" max="200" value="100" step="1">
    </div>
    <div class="control-group">
      <label for="scale">Uniform Scale</label>
      <input type="range" id="scale" min="0.5" max="2.0" value="1.0" step="0.01">
    </div>
    <div class="control-group">
      <label for="fillColor">Fill Color</label>
      <input type="color" id="fillColor" value="#1e1e1e">
    </div>
  </div>

  <div class="measurement" id="measurementDisplay">Total Measurement: 0</div>

  <div class="zoom-buttons">
    <button class="zoom-button" id="zoomIn"><i class="fas fa-plus"></i></button>
    <button class="zoom-button" id="zoomOut"><i class="fas fa-minus"></i></button>
  </div>

  <div class="controls-bottom-right">
    <div class="toggle-control" id="mirrorPatternContainer">
      <label for="mirrorPatternCheckbox">Mirror Pattern</label>
      <input type="checkbox" id="mirrorPatternCheckbox">
    </div>
    <div class="toggle-control" id="toggleLabelsContainer">
      <label for="toggleLabelsCheckbox">Show Labels</label>
      <input type="checkbox" id="toggleLabelsCheckbox" checked>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1e1e1e);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 200);

    const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('canvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const group = new THREE.Group();
    scene.add(group);
    
    const labelGroup = new THREE.Group();
    scene.add(labelGroup);

    const fontLoader = new FontLoader();
    let font;

    fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.153.0/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
      font = loadedFont;
      updatePattern();
    });

    const patternPresets = {
      basic: [
        { type: "line", points: [[90, 0], [90, 40]], label: "Line: (90,0) to (90,40)" },
        { type: "bezier", points: [[90, 40], [90, 60], [63, 80], [45, 100]], label: "Bezier: (90,40), (90,60), (63,80), (45,100)" },
        { type: "line", points: [[45, 100], [0, 100]], label: "Line: (45,100) to (0,100)" },
        { type: "line", points: [[0, 100], [0, 0]], label: "Line: (0,100) to (0,0)" },
        { type: "bezier", points: [[0, 0], [18, -40], [72, -40], [90, 0]], label: "Bezier: (0,0), (18,-40), (72,-40), (90,0)" }
      ],
      shirtWithCollar: [
        { type: "line", points: [[90, 0], [90, 40]], label: "Line: (90,0) to (90,40)" },
        { type: "bezier", points: [[90, 40], [90, 60], [63, 80], [45, 100]], label: "Bezier: (90,40), (90,60), (63,80), (45,100)" },
        { type: "line", points: [[45, 100], [0, 100]], label: "Line: (45,100) to (0,100)" },
        { type: "line", points: [[0, 100], [0, 40]], label: "Line: (0,100) to (0,40)" },
        { type: "bezier", points: [[0, 40], [18, -10], [72, -10], [90, 0]], label: "Bezier: (0,40), (18,-10), (72,-10), (90,0)" }
      ],
      shirtWithSleeves: [
        // Shirt body
        { type: "line", points: [[90, 0], [90, 40]], label: "Line: (90,0) to (90,40)" },
        { type: "bezier", points: [[90, 40], [90, 60], [63, 80], [45, 100]], label: "Bezier: (90,40), (90,60), (63,80), (45,100)" },
        { type: "line", points: [[45, 100], [0, 100]], label: "Line: (45,100) to (0,100)" },
        { type: "line", points: [[0, 100], [0, 0]], label: "Line: (0,100) to (0,0)" },
        { type: "bezier", points: [[0, 0], [18, -40], [72, -40], [90, 0]], label: "Bezier: (0,0), (18,-40), (72,-40), (90,0)" },
        // Right sleeve (separate shape)
        { type: "break" },
        { type: "bezier", points: [[90, 40], [110, 30], [130, 60], [150, 50]], label: "Bezier: (90,40), (110,30), (130,60), (150,50)" },
        { type: "line", points: [[150, 50], [160, 70]], label: "Line: (150,50) to (160,70)" },
        { type: "line", points: [[160, 70], [170, 90]], label: "Line: (160,70) to (170,90)" },
        { type: "line", points: [[170, 90], [160, 110]], label: "Line: (170,90) to (160,110)" },
        { type: "line", points: [[160, 110], [140, 120]], label: "Line: (160,110) to (140,120)" },
        { type: "line", points: [[140, 120], [130, 100]], label: "Line: (140,120) to (130,100)" },
        { type: "line", points: [[130, 100], [150, 100]], label: "Line: (130,100) to (150,100)" }
      ],
      shirtWithYoke: [
        { type: "line", points: [[90, 0], [90, 40]], label: "Line: (90,0) to (90,40)" },
        { type: "bezier", points: [[90, 40], [90, 60], [63, 80], [45, 100]], label: "Bezier: (90,40), (90,60), (63,80), (45,100)" },
        { type: "line", points: [[45, 100], [0, 100]], label: "Line: (45,100) to (0,100)" },
        { type: "line", points: [[0, 100], [0, 40]], label: "Line: (0,100) to (0,40)" },
        { type: "line", points: [[0, 40], [45, 40]], label: "Line: (0,40) to (45,40)" },
        { type: "line", points: [[45, 40], [90, 40]], label: "Line: (45,40) to (90,40)" }
      ],
      shirtFull: [
        { type: "line", points: [[20, 0], [80, 0]], label: "Line: (20,0) to (80,0)" },
        { type: "bezier", points: [[80, 0], [85, 5], [83, 10], [80, 12]], label: "Bezier: (80,0), (85,5), (83,10), (80,12)" },
        { type: "line", points: [[80, 12], [80, 30]], label: "Line: (80,12) to (80,30)" },
        { type: "bezier", points: [[80, 30], [78, 35], [75, 40], [70, 42]], label: "Bezier: (80,30), (78,35), (75,40), (70,42)" },
        { type: "bezier", points: [[70, 42], [65, 50], [60, 65], [60, 80]], label: "Bezier: (70,42), (65,50), (60,65), (60,80)" },
        { type: "line", points: [[60, 80], [60, 100]], label: "Line: (60,80) to (60,100)" },
        { type: "line", points: [[60, 100], [20, 100]], label: "Line: (60,100) to (20,100)" },
        { type: "line", points: [[20, 100], [20, 80]], label: "Line: (20,100) to (20,80)" },
        { type: "bezier", points: [[20, 80], [25, 65], [30, 50], [35, 42]], label: "Bezier: (20,80), (25,65), (30,50), (35,42)" },
        { type: "bezier", points: [[35, 42], [40, 40], [42, 35], [40, 30]], label: "Bezier: (35,42), (40,40), (42,35), (40,30)" },
        { type: "line", points: [[40, 30], [20, 12]], label: "Line: (40,30) to (20,12)" },
        { type: "line", points: [[20, 12], [20, 0]], label: "Line: (20,12) to (20,0)" },
        { type: "break"},
        { type: "line", points: [[120, 0], [180, 0]], label: "Line: (120,0) to (180,0)" },
        { type: "bezier", points: [[120, 0], [125, 5], [123, 15], [130, 18]], label: "Bezier: (120,0), (125,5), (123,15), (130,18)" },
        { type: "line", points: [[130, 18], [130, 32]], label: "Line: (130,18) to (130,32)" },
        { type: "bezier", points: [[130, 32], [132, 37], [135, 42], [140, 44]], label: "Bezier: (130,32), (132,37), (135,42), (140,44)" },
        { type: "bezier", points: [[140, 44], [145, 52], [150, 67], [150, 82]], label: "Bezier: (140,44), (145,52), (150,67), (150,82)" },
        { type: "line", points: [[150, 82], [150, 100]], label: "Line: (150,82) to (150,100)" },
        { type: "line", points: [[150, 100], [120, 100]], label: "Line: (150,100) to (120,100)" },
        { type: "line", points: [[120, 100], [120, 82]], label: "Line: (120,100) to (120,82)" },
        { type: "bezier", points: [[120, 82], [125, 67], [130, 52], [135, 44]], label: "Bezier: (120,82), (125,67), (130,52), (135,44)" },
        { type: "bezier", points: [[135, 44], [138, 42], [140, 37], [138, 32]], label: "Bezier: (135,44), (138,42), (140,37), (138,32)" },
        { type: "line", points: [[138, 32], [120, 18]], label: "Line: (138,32) to (120,18)" },
        { type: "line", points: [[120, 18], [120, 0]], label: "Line: (120,18) to (120,0)" }
      ]
    };

    // Function to generate and add a single pattern piece (original or mirrored)
    const generatePatternShape = (patternData, width, height, colorHex, isMirrored = false) => {
      let shape = new THREE.Shape();
      let lastPoint = null;

      const addShapeToGroup = (shp) => {
        if (shp && shp.getPoints().length > 1) {
          const geometry = new THREE.ShapeGeometry(shp);
          const fill = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
            color: new THREE.Color(colorHex),
            side: THREE.DoubleSide
          }));
          group.add(fill);

          const edgeGeo = new THREE.EdgesGeometry(geometry);
          const edgeMat = new THREE.LineBasicMaterial({ color: 0xffffff });
          const edgeLines = new THREE.LineSegments(edgeGeo, edgeMat);
          group.add(edgeLines);
        }
      };

      patternData.forEach((segment) => {
        if (segment.type === "break") {
          addShapeToGroup(shape);
          shape = new THREE.Shape(); // Start a new shape for the next piece
          lastPoint = null;
          return;
        }

        // Apply mirroring to points if isMirrored is true
        const processedPoints = segment.points.map(p => isMirrored ? [-p[0], p[1]] : [p[0], p[1]]);
        const scaled = processedPoints.map(p => new THREE.Vector2(p[0] * (width / 100), p[1] * (height / 100)));
        const start = scaled[0];

        if (!lastPoint || !lastPoint.equals(start)) {
          shape.moveTo(start.x, start.y);
        }

        let labelPosition;
        // let labelText = segment.label || ""; // labelText definition moved inside the conditional block

        if (segment.type === "line") {
          shape.lineTo(scaled[1].x, scaled[1].y);
          lastPoint = scaled[1];
          labelPosition = new THREE.Vector3((scaled[0].x + scaled[1].x) / 2, (scaled[0].y + scaled[1].y) / 2, 5);
        } else if (segment.type === "bezier") {
          shape.bezierCurveTo(scaled[1].x, scaled[1].y, scaled[2].x, scaled[2].y, scaled[3].x, scaled[3].y);
          lastPoint = scaled[3];
          labelPosition = new THREE.Vector3(scaled[0].x, scaled[0].y - 5, 5);
        }
        
        // MODIFIED CONDITION: Only create labels if NOT mirrored and labels are visible
        if (font && segment.label && labelGroup.visible && !isMirrored) {
          const labelText = segment.label || ""; // Define labelText here
          
          const textGeometry = new TextGeometry(labelText, {
            font: font,
            size: 4,
            height: 0.1,
            curveSegments: 4,
            bevelEnabled: false,
          });
          const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const textMesh = new THREE.Mesh(textGeometry, textMaterial);
          textMesh.position.copy(labelPosition);
          textMesh.lookAt(camera.position); 
          labelGroup.add(textMesh); 
        }
      });
      addShapeToGroup(shape); 
    };

    const calculateTotalMeasurement = (patternData, currentWidth, currentHeight) => {
      let total = 0;
      patternData.forEach((segment) => {
        if (segment.type === "break") return;
        // Use original points for measurement, scaled by current width/height factors
        const scaledPoints = segment.points.map(p => new THREE.Vector2(p[0] * (currentWidth / 100), p[1] * (currentHeight / 100)));
        for (let i = 1; i < scaledPoints.length; i++) {
            // For bezier, this is an approximation (chord length). True arc length is more complex.
            // For simplicity, we sum lengths of defining points for bezier too.
            if (segment.type === "line" || segment.type === "bezier") { // Treat bezier points similarly for this rough calc
                 total += scaledPoints[i].distanceTo(scaledPoints[i - 1]);
            }
        }
         // A more accurate bezier length calculation would involve integrating its derivative or using an approximation method.
         // Current method for bezier will give length of control polygon, not the curve itself.
      });
      return total;
    };

    const patternSelect = document.getElementById('patternPreset');
    const widthSlider = document.getElementById('width');
    const heightSlider = document.getElementById('height');
    const scaleSlider = document.getElementById('scale');
    const colorInput = document.getElementById('fillColor');
    const measurementDisplay = document.getElementById('measurementDisplay');
    
    const toggleLabelsCheckbox = document.getElementById('toggleLabelsCheckbox');
    const mirrorPatternCheckbox = document.getElementById('mirrorPatternCheckbox');


    toggleLabelsCheckbox.addEventListener('change', () => {
      labelGroup.visible = toggleLabelsCheckbox.checked;
      updatePattern(); // Redraw to show/hide labels
    });
    
    mirrorPatternCheckbox.addEventListener('change', updatePattern);


    function updatePattern() {
      if (!font) return; // Don't draw if font isn't loaded

      // Clear existing pattern and labels from the groups
      while(group.children.length > 0){ group.remove(group.children[0]); }
      while(labelGroup.children.length > 0){ labelGroup.remove(labelGroup.children[0]); }

      const patternName = patternSelect.value;
      // Use a deep copy of the preset data to avoid modifying the original presets
      const originalPatternData = JSON.parse(JSON.stringify(patternPresets[patternName])); 
      
      let currentWidth = parseFloat(widthSlider.value);
      let currentHeight = parseFloat(heightSlider.value);
      const scale = parseFloat(scaleSlider.value);
      const fillColor = colorInput.value;

      // Apply uniform scale
      // Note: The actual points in patternPresets are defined relative to a 100x100 box.
      // The width/height sliders then stretch this. Scale is an additional multiplier.
      // For simplicity in generatePatternShape, we'll pass scaled width/height.
      // Or, adjust points directly. Let's adjust width/height passed.
      const effectiveWidth = currentWidth * scale;
      const effectiveHeight = currentHeight * scale;
      
      // Generate and add the original pattern
      generatePatternShape(originalPatternData, effectiveWidth, effectiveHeight, fillColor, false);

      if (mirrorPatternCheckbox.checked) {
        // Generate and add the mirrored pattern.
        // The `isMirrored = true` flag in generatePatternShape will handle negating x-coordinates.
        generatePatternShape(originalPatternData, effectiveWidth, effectiveHeight, fillColor, true);
      }
      
      // Calculate measurement based on the original pattern data and current dimensions
      const totalMeasurement = calculateTotalMeasurement(originalPatternData, effectiveWidth, effectiveHeight);
      // If mirrored, the total material might be considered double, but the measurement here refers to one piece.
      measurementDisplay.textContent = `Total Measurement: ${totalMeasurement.toFixed(2)} cm`;
    }

    patternSelect.addEventListener('change', updatePattern);
    widthSlider.addEventListener('input', updatePattern);
    heightSlider.addEventListener('input', updatePattern);
    scaleSlider.addEventListener('input', updatePattern);
    colorInput.addEventListener('input', updatePattern);

    const zoomInButton = document.getElementById('zoomIn');
    const zoomOutButton = document.getElementById('zoomOut');

    zoomInButton.addEventListener('click', () => {
      camera.position.z = Math.max(camera.position.z - 20, 10); // Prevent zooming too close
      controls.update();
    });

    zoomOutButton.addEventListener('click', () => {
      camera.position.z += 20;
      controls.update();
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const animate = () => {
      requestAnimationFrame(animate);
      controls.update(); // Only if damping or auto-rotation is enabled
      renderer.render(scene, camera);
    };
    
    // Initial call to draw the pattern once everything is set up (font might still be loading)
    // updatePattern() is called inside fontLoader callback for the very first draw.
    animate();

  </script>
</body>
</html>